# Job para Configura√ß√£o Inicial do RabbitMQ
# Executa ap√≥s o RabbitMQ estar pronto para configurar filas e permiss√µes

apiVersion: batch/v1
kind: Job
metadata:
  name: rabbitmq-setup
  namespace: default
  labels:
    app: rabbitmq-setup
spec:
  ttlSecondsAfterFinished: 300  # Remove job ap√≥s 5 minutos de conclus√£o
  template:
    metadata:
      labels:
        app: rabbitmq-setup
    spec:
      restartPolicy: OnFailure
      containers:
      - name: rabbitmq-setup
        image: rabbitmq:3.12-management
        command:
        - /bin/bash
        - -c
        - |
          echo "üöÄ Iniciando configura√ß√£o do RabbitMQ..."
          
          # Fun√ß√£o para aguardar RabbitMQ estar pronto
          wait_for_rabbitmq() {
            local max_attempts=20
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "‚è≥ Tentativa $attempt/$max_attempts - Verificando RabbitMQ..."
              
              # Descobrir o nome do pod RabbitMQ
              RABBITMQ_POD=$(kubectl get pods -l app=rabbitmq -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
              if [ -z "$RABBITMQ_POD" ]; then
                echo "‚ö†Ô∏è Pod RabbitMQ n√£o encontrado, aguardando 10s..."
                sleep 10
                attempt=$((attempt + 1))
                continue
              fi
              
              # Testar ping no pod espec√≠fico
              if rabbitmq-diagnostics -n rabbit@$RABBITMQ_POD ping > /dev/null 2>&1; then
                echo "‚úÖ RabbitMQ est√° respondendo no pod: $RABBITMQ_POD"
                export RABBITMQ_POD
                return 0
              fi
              
              echo "‚ö†Ô∏è RabbitMQ ainda n√£o est√° pronto, aguardando 10s..."
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå Timeout aguardando RabbitMQ ap√≥s $((max_attempts * 10))s"
            return 1
          }
          
          # Aguardar RabbitMQ estar pronto
          if ! wait_for_rabbitmq; then
            echo "‚ùå Falha ao conectar com RabbitMQ"
            exit 1
          fi
          
          echo "üîß Configurando loopback_users no pod: $RABBITMQ_POD..."
          # Configurar loopback users para permitir conex√µes remotas do guest
          if rabbitmqctl -n rabbit@$RABBITMQ_POD eval 'application:set_env(rabbit, loopback_users, []).'; then
            echo "‚úÖ Configura√ß√£o loopback_users aplicada com sucesso"
          else
            echo "‚ö†Ô∏è Falha ao configurar loopback_users (pode j√° estar configurado)"
          fi
          
          echo "üìã Criando filas necess√°rias..."
          
          # Criar filas para Azure Functions
          queues=("pne-email" "pne-integracao-rota" "pne-integracao-arquivo")
          
          for queue in "${queues[@]}"; do
            echo "üì¶ Criando fila: $queue"
            if rabbitmqadmin -H rabbitmq-service declare queue name="$queue" durable=true; then
              echo "‚úÖ Fila $queue criada com sucesso"
            else
              echo "‚ö†Ô∏è Fila $queue pode j√° existir ou houve erro"
            fi
          done
          
          echo "üìä Verificando status final..."
          
          # Verificar filas criadas
          echo "üìã Listando filas:"
          rabbitmqctl -n rabbit@$RABBITMQ_POD list_queues name messages
          
          # Verificar configura√ß√£o loopback
          echo "üîç Verificando configura√ß√£o loopback:"
          rabbitmqctl -n rabbit@$RABBITMQ_POD eval 'application:get_env(rabbit, loopback_users).'
          
          echo "üéâ Configura√ß√£o do RabbitMQ conclu√≠da com sucesso!"
          
        env:
        - name: RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS
          value: "-rabbit loopback_users []"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
      # Aguardar at√© 10 minutos para o job completar
      activeDeadlineSeconds: 600